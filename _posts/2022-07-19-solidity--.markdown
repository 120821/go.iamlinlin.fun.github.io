---
layout: post
title: "根据例子学习Solidity--投票"
date: "2022-07-19"
categories: 
---
<p>https://solidity-cn.readthedocs.io/zh/develop/solidity-by-example.html</p>

<p>投票</p>

<p>以下的合约相当复杂，但展示了很多Solidity的功能。它实现了一个投票合约。 当然，电子投票的主要问题是如何将投票权分配给正确的人员以及如何防止被操纵。 我们不会在这里解决所有的问题，但至少我们会展示如何进行委托投票，同时，计票又是 <strong>自动和完全透明的</strong> 。</p>

<p>我们的想法是为每个（投票）表决创建一份合约，为每个选项提供简称。 然后作为合约的创造者&mdash;&mdash;即主席，将给予每个独立的地址以投票权。</p>

<p>地址后面的人可以选择自己投票，或者委托给他们信任的人来投票。</p>

<p>在投票时间结束时，<code class="docutils literal notranslate"><span class="pre">winningProposal()</span>{% endhighlight %} 将返回获得最多投票的提案。</p>

{% highlight %}
<span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>

<span class="cs">/// </span><span class="k">@title</span><span class="cs"> 委托投票</span>
<span class="kd">contract</span> <span class="nx">Ballot</span> <span class="p">{</span>
    <span class="c1">// 这里声明了一个新的复合类型用于稍后的变量</span>
    <span class="c1">// 它用来表示一个选民</span>
    <span class="kd">struct</span> <span class="nx">Voter</span> <span class="p">{</span>
        <span class="kt">uint</span> <span class="nx">weight</span><span class="p">;</span> <span class="c1">// 计票的权重</span>
        <span class="kt">bool</span> <span class="nx">voted</span><span class="p">;</span>  <span class="c1">// 若为真，代表该人已投票</span>
        <span class="kt">address</span> <span class="nx">delegate</span><span class="p">;</span> <span class="c1">// 被委托人</span>
        <span class="kt">uint</span> <span class="nx">vote</span><span class="p">;</span>   <span class="c1">// 投票提案的索引</span>
    <span class="p">}</span>

    <span class="c1">// 提案的类型</span>
    <span class="kd">struct</span> <span class="nx">Proposal</span> <span class="p">{</span>
        <span class="kt">bytes32</span> <span class="nx">name</span><span class="p">;</span>   <span class="c1">// 简称（最长32个字节）</span>
        <span class="kt">uint</span> <span class="nx">voteCount</span><span class="p">;</span> <span class="c1">// 得票数</span>
    <span class="p">}</span>

    <span class="kt">address</span> <span class="k">public</span> <span class="nx">chairperson</span><span class="p">;</span>

    <span class="c1">// 这声明了一个状态变量，为每个可能的地址存储一个 `Voter`。</span>
    <span class="k">mapping</span><span class="p">(</span><span class="kt">address</span> <span class="o">=&gt;</span> <span class="nx">Voter</span><span class="p">)</span> <span class="k">public</span> <span class="nx">voters</span><span class="p">;</span>

    <span class="c1">// 一个 `Proposal` 结构类型的动态数组</span>
    <span class="nx">Proposal</span><span class="p">[]</span> <span class="k">public</span> <span class="nx">proposals</span><span class="p">;</span>

    <span class="cs">/// 为 `proposalNames` 中的每个提案，创建一个新的（投票）表决</span>
    <span class="nx">constructor</span><span class="p">(</span><span class="kt">bytes32</span><span class="p">[]</span> <span class="nx">proposalNames</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nx">chairperson</span> <span class="o">=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">;</span>
        <span class="nx">voters</span><span class="p">[</span><span class="nx">chairperson</span><span class="p">].</span><span class="nx">weight</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="c1">//对于提供的每个提案名称，</span>
        <span class="c1">//创建一个新的 Proposal 对象并把它添加到数组的末尾。</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">proposalNames</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// `Proposal({...})` 创建一个临时 Proposal 对象，</span>
            <span class="c1">// `proposals.push(...)` 将其添加到 `proposals` 的末尾</span>
            <span class="nx">proposals</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">Proposal</span><span class="p">({</span>
                <span class="nx">name</span><span class="o">:</span> <span class="nx">proposalNames</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span>
                <span class="nx">voteCount</span><span class="o">:</span> <span class="mi">0</span>
            <span class="p">}));</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 授权 `voter` 对这个（投票）表决进行投票</span>
    <span class="c1">// 只有 `chairperson` 可以调用该函数。</span>
    <span class="kd">function</span> <span class="nx">giveRightToVote</span><span class="p">(</span><span class="kt">address</span> <span class="nx">voter</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="c1">// 若 `require` 的第一个参数的计算结果为 `false`，</span>
        <span class="c1">// 则终止执行，撤销所有对状态和以太币余额的改动。</span>
        <span class="c1">// 在旧版的 EVM 中这曾经会消耗所有 gas，但现在不会了。</span>
        <span class="c1">// 使用 require 来检查函数是否被正确地调用，是一个好习惯。</span>
        <span class="c1">// 你也可以在 require 的第二个参数中提供一个对错误情况的解释。</span>
        <span class="nb">require</span><span class="p">(</span>
            <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">==</span> <span class="nx">chairperson</span><span class="p">,</span>
            <span class="s2">&quot;Only chairperson can give right to vote.&quot;</span>
        <span class="p">);</span>
        <span class="nb">require</span><span class="p">(</span>
            <span class="o">!</span><span class="nx">voters</span><span class="p">[</span><span class="nx">voter</span><span class="p">].</span><span class="nx">voted</span><span class="p">,</span>
            <span class="s2">&quot;The voter already voted.&quot;</span>
        <span class="p">);</span>
        <span class="nb">require</span><span class="p">(</span><span class="nx">voters</span><span class="p">[</span><span class="nx">voter</span><span class="p">].</span><span class="nx">weight</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
        <span class="nx">voters</span><span class="p">[</span><span class="nx">voter</span><span class="p">].</span><span class="nx">weight</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cs">/// 把你的投票委托到投票者 `to`。</span>
    <span class="kd">function</span> <span class="nx">delegate</span><span class="p">(</span><span class="kt">address</span> <span class="nx">to</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="c1">// 传引用</span>
        <span class="nx">Voter</span> <span class="k">storage</span> <span class="nx">sender</span> <span class="o">=</span> <span class="nx">voters</span><span class="p">[</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">];</span>
        <span class="nb">require</span><span class="p">(</span><span class="o">!</span><span class="nx">sender</span><span class="p">.</span><span class="nx">voted</span><span class="p">,</span> <span class="s2">&quot;You already voted.&quot;</span><span class="p">);</span>

        <span class="nb">require</span><span class="p">(</span><span class="nx">to</span> <span class="o">!=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">,</span> <span class="s2">&quot;Self-delegation is disallowed.&quot;</span><span class="p">);</span>

        <span class="c1">// 委托是可以传递的，只要被委托者 `to` 也设置了委托。</span>
        <span class="c1">// 一般来说，这种循环委托是危险的。因为，如果传递的链条太长，</span>
        <span class="c1">// 则可能需消耗的gas要多于区块中剩余的（大于区块设置的gasLimit），</span>
        <span class="c1">// 这种情况下，委托不会被执行。</span>
        <span class="c1">// 而在另一些情况下，如果形成闭环，则会让合约完全卡住。</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">voters</span><span class="p">[</span><span class="nx">to</span><span class="p">].</span><span class="nx">delegate</span> <span class="o">!=</span> <span class="kt">address</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
            <span class="nx">to</span> <span class="o">=</span> <span class="nx">voters</span><span class="p">[</span><span class="nx">to</span><span class="p">].</span><span class="nx">delegate</span><span class="p">;</span>

            <span class="c1">// 不允许闭环委托</span>
            <span class="nb">require</span><span class="p">(</span><span class="nx">to</span> <span class="o">!=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">,</span> <span class="s2">&quot;Found loop in delegation.&quot;</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// `sender` 是一个引用, 相当于对 `voters[msg.sender].voted` 进行修改</span>
        <span class="nx">sender</span><span class="p">.</span><span class="nx">voted</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="nx">sender</span><span class="p">.</span><span class="nx">delegate</span> <span class="o">=</span> <span class="nx">to</span><span class="p">;</span>
        <span class="nx">Voter</span> <span class="k">storage</span> <span class="nx">delegate_</span> <span class="o">=</span> <span class="nx">voters</span><span class="p">[</span><span class="nx">to</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">delegate_</span><span class="p">.</span><span class="nx">voted</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 若被委托者已经投过票了，直接增加得票数</span>
            <span class="nx">proposals</span><span class="p">[</span><span class="nx">delegate_</span><span class="p">.</span><span class="nx">vote</span><span class="p">].</span><span class="nx">voteCount</span> <span class="o">+=</span> <span class="nx">sender</span><span class="p">.</span><span class="nx">weight</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// 若被委托者还没投票，增加委托者的权重</span>
            <span class="nx">delegate_</span><span class="p">.</span><span class="nx">weight</span> <span class="o">+=</span> <span class="nx">sender</span><span class="p">.</span><span class="nx">weight</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cs">/// 把你的票(包括委托给你的票)，</span>
    <span class="cs">/// 投给提案 `proposals[proposal].name`.</span>
    <span class="kd">function</span> <span class="nx">vote</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">proposal</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nx">Voter</span> <span class="k">storage</span> <span class="nx">sender</span> <span class="o">=</span> <span class="nx">voters</span><span class="p">[</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">];</span>
        <span class="nb">require</span><span class="p">(</span><span class="o">!</span><span class="nx">sender</span><span class="p">.</span><span class="nx">voted</span><span class="p">,</span> <span class="s2">&quot;Already voted.&quot;</span><span class="p">);</span>
        <span class="nx">sender</span><span class="p">.</span><span class="nx">voted</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="nx">sender</span><span class="p">.</span><span class="nx">vote</span> <span class="o">=</span> <span class="nx">proposal</span><span class="p">;</span>

        <span class="c1">// 如果 `proposal` 超过了数组的范围，则会自动抛出异常，并恢复所有的改动</span>
        <span class="nx">proposals</span><span class="p">[</span><span class="nx">proposal</span><span class="p">].</span><span class="nx">voteCount</span> <span class="o">+=</span> <span class="nx">sender</span><span class="p">.</span><span class="nx">weight</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cs">/// </span><span class="k">@dev</span><span class="cs"> 结合之前所有的投票，计算出最终胜出的提案</span>
    <span class="kd">function</span> <span class="nx">winningProposal</span><span class="p">()</span> <span class="k">public</span> <span class="k">view</span>
            <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">winningProposal_</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">uint</span> <span class="nx">winningVoteCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">p</span> <span class="o">&lt;</span> <span class="nx">proposals</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">proposals</span><span class="p">[</span><span class="nx">p</span><span class="p">].</span><span class="nx">voteCount</span> <span class="o">&gt;</span> <span class="nx">winningVoteCount</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">winningVoteCount</span> <span class="o">=</span> <span class="nx">proposals</span><span class="p">[</span><span class="nx">p</span><span class="p">].</span><span class="nx">voteCount</span><span class="p">;</span>
                <span class="nx">winningProposal_</span> <span class="o">=</span> <span class="nx">p</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 调用 winningProposal() 函数以获取提案数组中获胜者的索引，并以此返回获胜者的名称</span>
    <span class="kd">function</span> <span class="nx">winnerName</span><span class="p">()</span> <span class="k">public</span> <span class="k">view</span>
            <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes32</span> <span class="nx">winnerName_</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nx">winnerName_</span> <span class="o">=</span> <span class="nx">proposals</span><span class="p">[</span><span class="nx">winningProposal</span><span class="p">()].</span><span class="nx">name</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>{% endhighlight %}


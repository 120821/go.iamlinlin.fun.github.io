---
layout: post
title: "ruby入门算法--两数之和"
date: "2022-06-09"
categories: 
---

                    <blockquote> 
 <h1>Ruby 范围（Range）</h1> 
 <p>范围（Range）无处不在：a 到 z、 0 到 9、等等。Ruby 支持范围，并允许我们以不同的方式使用范围：</p> 
 <ul>
<li>作为序列的范围</li>
<li>作为条件的范围</li>
<li>作为间隔的范围</li>
</ul>
 <h2>作为序列的范围</h2> 
 <p>范围的第一个也是最常见的用途是表达序列。序列有一个起点、一个终点和一个在序列产生连续值的方式。</p> 
 <p>Ruby 使用 <strong>''..''</strong> 和 <strong>''...''</strong> 范围运算符创建这些序列。两点形式创建一个包含指定的最高值的范围，三点形式创建一个不包含指定的最高值的范围</p> 
 <pre><code>(1..5)        #==&gt; 1, 2, 3, 4, 5
(1...5)       #==&gt; 1, 2, 3, 4
('a'..'d')    #==&gt; 'a', 'b', 'c', 'd'</code></pre> 
 <p>序列 1..100 是一个 <em>Range</em> 对象，包含了两个 <em>Fixnum</em> 对象的引用。如果需要，您可以使用 <em>to_a</em> 方法把范围转换为列表。</p> 
 <pre><code class="language-ruby">
#!/usr/bin/ruby
 
$, =", "   # Array 值分隔符
range1 = (1..10).to_a
range2 = ('bar'..'bat').to_a
 
puts "#{range1}"
puts "#{range2}"

以上实例运行输出结果为：

[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
["bar", "bas", "bat"]</code></pre> 
 <pre><code class="language-ruby"># 指定范围
digits = 0..9

puts digits.include?(5)
ret = digits.min
puts "最小值为 #{ret}"

ret = digits.max
puts "最大值为 #{ret}"

ret = digits.reject {|i| i &lt; 5 }
puts "不符合条件的有 #{ret}"

digits.each do |digit|
   puts "在循环中 #{digit}"
end</code></pre> 
 <p><img alt="" height="344" src="https://img-blog.csdnimg.cn/cf5f77ab5b074238a0ed5994fc0b7376.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6K645aKo44Gu5bCP6J206J22,size_7,color_FFFFFF,t_70,g_se,x_16" width="281"></p> 
 <p> </p> 
 <p>方法一：暴力枚举</p> 
 <p>枚举数组中的每一个数 x，寻找数组中是否存在 target - x。</p> 
 <p>遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以只需要在 x 后面的元素中寻找 target - x</p> 
 <pre><code class="language-ruby">def two_sum(nums, target)
  nums.each_with_index do |e, i|
    pi = nums.index(target - e)
    return [i, pi] if pi &amp;&amp; pi != i
  end
end</code></pre> 
 <p>   <strong> 哈希</strong></p> 
 <p>创建一个哈希表，对于每一个 x，查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。</p> 
 <pre><code class="language-ruby">def two_sum(nums, target)
   hash = {}

   nums.each_with_index do |e, i|
    return [hash[e], i] if hash.has_key?(e)
    hash[target - e] = i
   end
end</code></pre> 
 <p></p> 
</blockquote> 
<p></p>
                

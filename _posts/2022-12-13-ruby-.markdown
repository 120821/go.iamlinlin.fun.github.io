---
layout: post
title: "Ruby设计模式 - 单例模式"
date: "2022-12-13"
categories: 
---
<p>参考： <a href="https://www.zhangshengrong.com/p/ArXGv75Njy/">https://www.zhangshengrong.com/p/ArXGv75Njy/</a></p>

<p>单例模式是设计模式中最简单的形式之一。这一模式的目的是使得类的一个对象成为系统中的唯一实例。要实现这一点，可以从客户端对其进行实例化开始。因此需要用一种只允许生成对象类的唯一实例的机制，&ldquo;阻止&rdquo;所有想要生成对象的访问。使用工厂方法来限制实例化过程。这个方法应该是静态方法（类方法），因为让类的实例去生成另一个唯一实例毫无意义</p>

<p>单例模式的要点有三个；一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。</p>

<p>从实现角度：一是单例模式的类只提供私有的构造函数，二是类定义中含有一个该类的静态私有对象，三是该类提供了</p>
<pre><code>&nbsp;&nbsp;&nbsp; <code>class ClassVariableTester<br />
&nbsp;&nbsp;&nbsp;&nbsp; @@class_count = 0<br />
&nbsp;&nbsp;&nbsp; &nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp; def initialize<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @instance_count = 0<br />
&nbsp;&nbsp;&nbsp;&nbsp; end<br />
&nbsp;&nbsp;&nbsp; &nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp; def increment<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @@class_count = @@class_count + 1<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @instance_count = @instance_count + 1<br />
&nbsp;&nbsp;&nbsp;&nbsp; end<br />
&nbsp;&nbsp;&nbsp; &nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp; def to_s<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;class count :#{@@class_count} -- instance count :#{@instance_count}&quot;<br />
&nbsp;&nbsp;&nbsp;&nbsp; end<br />
&nbsp;&nbsp;&nbsp; &nbsp;<br />
&nbsp;&nbsp;&nbsp; end<br />
&nbsp;&nbsp;&nbsp; &nbsp;<br />
&nbsp;&nbsp;&nbsp; cv1 = ClassVariableTester.new<br />
&nbsp;&nbsp;&nbsp; cv1.increment<br />
&nbsp;&nbsp;&nbsp; cv1.increment<br />
&nbsp;&nbsp;&nbsp; puts(&quot;cv1:#{cv1}&quot;)<br />
&nbsp;&nbsp;&nbsp; cv2 = ClassVariableTester.new<br />
&nbsp;&nbsp;&nbsp; puts(&quot;cv2:#{cv2}&quot;)<br />
&nbsp;&nbsp;&nbsp; &nbsp;<br />
&nbsp;&nbsp;&nbsp; #cv1:class count :2 -- instance count :2<br />
&nbsp;&nbsp;&nbsp; #cv2:class count :2 -- instance count :0</code></pre>

<p>当创建了第二个对象时，@@class_count 为2，二@instance_count为0，因为类变量被所有实例所共享，cv1.increment调用了两次以后@@class_count为2，创建第二个ClassVariableTester对象cv2的时候，共享了@@class_count，所以此时的@@class_count仍为2。<br />
而实例变量只能为当前对象服务，所以实例对象cv2的@@instance_count为0&nbsp;<br />
类变量的这种特性是一种单例模式</p>

<pre><code>class SimpleLogger<br />
&nbsp;&nbsp;&nbsp; &nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp; @@instance = SimpleLogger.new<br />
&nbsp;&nbsp;&nbsp; &nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp; def self.get_instance<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @@instance<br />
&nbsp;&nbsp;&nbsp;&nbsp; end<br />
&nbsp;&nbsp;&nbsp; &nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp; private_class_method :new<br />
&nbsp;&nbsp;&nbsp; end<br />
&nbsp;&nbsp;&nbsp; &nbsp;<br />
&nbsp;&nbsp;&nbsp; sl1 = SimpleLogger.get_instance<br />
&nbsp;&nbsp;&nbsp; sl2 = SimpleLogger.get_instance<br />
&nbsp;&nbsp;&nbsp; puts sl1 == sl2</code></pre>

<p>返回 true</p>

<p>采用一个类变量来保存仅有的一个类的实例，同时需要一个类方法返回这个单例实例。&nbsp;<br />
但是通过SimpleLogger.new还是可以创建另一个实例对象，因此需要把着个new方法设为私有的。</p>

<pre><code>&nbsp;sl3 = SimpleLogger.new<br />
&nbsp;&nbsp;&nbsp;&nbsp; private method `new&#39; called for SimpleLogger:Class (NoMethodError)<br />
&nbsp;&nbsp;&nbsp; &nbsp;<br />
&nbsp;&nbsp;&nbsp; require &#39;singleton&#39;<br />
&nbsp;&nbsp;&nbsp; class SimpleLogger<br />
&nbsp;&nbsp;&nbsp;&nbsp; include Singleton<br />
&nbsp;&nbsp;&nbsp; &nbsp;<br />
&nbsp;&nbsp;&nbsp; end<br />
&nbsp;&nbsp;&nbsp; &nbsp;<br />
&nbsp;&nbsp;&nbsp; #puts SimpleLogger.new<br />
&nbsp;&nbsp;&nbsp; sl1 = SimpleLogger.instance<br />
&nbsp;&nbsp;&nbsp; sl2 = SimpleLogger.instance<br />
&nbsp;&nbsp;&nbsp; puts sl1 == sl2</code></pre>

<p>结果为：true&nbsp;</p>

<p>Ruby类库中提供了singleton，来简化单例类的创建。 &nbsp;</p>

<p>混入Singleton，就省略了创建类变量，初始化单例实例，创建类级别的instance方法，以及将new设为私有。 &nbsp;</p>

<p>通过SimpleLogger.instance来获取日志器的单例。&nbsp;</p>

<p>但是两种方式还是又差异的。 &nbsp;</p>

<p>第一种方式称之为&ldquo;勤性单例(eager instantiation)&rdquo;。 &nbsp;</p>

<p>在确实需要之前就创建了实例对象。 &nbsp;</p>

<p>第二种方式称之为&ldquo;惰性单例(lazy instantiation)&rdquo; &nbsp;</p>

<p>在调用instance时才会去创建&nbsp; 。</p>

<p>但是这个Singleton不能真正的阻止任何事情，可以用过public_class_method改变new方法的为公用的。 &nbsp;</p>

<p>打开类，设置new方法为public之后，就可以用SimpleLogger.new来创建对象了。</p>

<pre>&nbsp;<code>&nbsp;&nbsp; class SimpleLogger<br />
&nbsp;&nbsp;&nbsp;&nbsp; public_class_method :new<br />
&nbsp;&nbsp;&nbsp; end</code><br />
&nbsp;&nbsp;&nbsp; &nbsp;<br />
&nbsp;&nbsp;&nbsp; puts SimpleLogger.new</code></pre>

<p>再来分两种情况：</p>

<p>(一)使用全局变量，尽量不要使用全局变量，因为全局变量是程序紧密的耦合在一起， &nbsp;</p>

<p>其实单例模式和全局变量的作用是一样的， &nbsp;</p>

<pre><code>$logger = SimpleLogger.new</code></pre>

<p>(二)使用类作为单例，</p>

<pre>&nbsp;&nbsp;&nbsp; <code>class SimpleLogger<br />
&nbsp;&nbsp;&nbsp; &nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp; WARNING = 1<br />
&nbsp;&nbsp;&nbsp;&nbsp; INFO = 2<br />
&nbsp;&nbsp;&nbsp; &nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp; def initialize(file)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @@log = File.open(file, &quot;w&quot;)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @@level = WARNING<br />
&nbsp;&nbsp;&nbsp;&nbsp; end<br />
&nbsp;&nbsp;&nbsp; &nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp; def self.warning(msg)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts @@level &gt; WARNING<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @@log.puts(msg) if @@level &gt; WARNING<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @@log.flush<br />
&nbsp;&nbsp;&nbsp;&nbsp; end<br />
&nbsp;&nbsp;&nbsp; &nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp; def self.level<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @@level<br />
&nbsp;&nbsp;&nbsp;&nbsp; end<br />
&nbsp;&nbsp;&nbsp; &nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp; def self.level=(new_level)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @@level = new_level<br />
&nbsp;&nbsp;&nbsp;&nbsp; end<br />
&nbsp;&nbsp;&nbsp; &nbsp;<br />
&nbsp;&nbsp;&nbsp; end<br />
&nbsp;&nbsp;&nbsp; SimpleLogger.new(&quot;test.txt&quot;)<br />
&nbsp;&nbsp;&nbsp; puts SimpleLogger.level<br />
&nbsp;&nbsp;&nbsp; SimpleLogger.level = SimpleLogger::INFO<br />
&nbsp;&nbsp;&nbsp; puts SimpleLogger.level<br />
&nbsp;&nbsp;&nbsp; SimpleLogger.warning(&quot;warning&quot;)</code></pre>

<p>实例</p>

<pre>&nbsp;&nbsp;&nbsp;<code> require &#39;rubygems&#39;<br />
&nbsp;&nbsp;&nbsp; require &#39;watir&#39;<br />
&nbsp;&nbsp;&nbsp; require &#39;singleton&#39;<br />
&nbsp;&nbsp;&nbsp; class AutoTest<br />
&nbsp;&nbsp;&nbsp;&nbsp; include Singleton<br />
&nbsp;&nbsp;&nbsp;&nbsp; def OpenUrl(url)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @browser= Watir::Browser.new<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @browser.goto(url)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @url=url<br />
&nbsp;&nbsp;&nbsp;&nbsp; end<br />
&nbsp;&nbsp;&nbsp;&nbsp; def set_textarea(text)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @browser.text_field(:id,&#39;kw&#39;).set(text)<br />
&nbsp;&nbsp;&nbsp;&nbsp; end<br />
&nbsp;&nbsp;&nbsp;&nbsp; def click<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @browser.button(:id,&#39;su&#39;).click<br />
&nbsp;&nbsp;&nbsp;&nbsp; end<br />
&nbsp;&nbsp;&nbsp; end<br />
&nbsp;&nbsp;&nbsp; test,test2 = AutoTest.instance<br />
&nbsp;&nbsp;&nbsp; test.OpenUrl(&#39;http://www.baidu.com&#39;)<br />
&nbsp;&nbsp;&nbsp; test.set_textarea(&#39;aslandhu&#39;)<br />
&nbsp;&nbsp;&nbsp; test.click</code></pre>

<p>这里虽然创建了两个AutoTest实例，但是第二个实例其实为nil，也就是说并没有创建成功。</p>

<pre><code>&nbsp;&nbsp;&nbsp; require &#39;rubygems&#39;<br />
&nbsp;&nbsp;&nbsp; require &#39;watir&#39;<br />
&nbsp;&nbsp;&nbsp; require &#39;singleton&#39;<br />
&nbsp;&nbsp;&nbsp; require &#39;thread&#39;<br />
&nbsp;&nbsp;&nbsp; class TestOneObj<br />
&nbsp;&nbsp;&nbsp; &nbsp;<br />
&nbsp;&nbsp;&nbsp; end<br />
&nbsp;&nbsp;&nbsp; class &lt;&lt;TestOneObj<br />
&nbsp;&nbsp;&nbsp;&nbsp; include Singleton<br />
&nbsp;&nbsp;&nbsp;&nbsp; def instance<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @browser= Watir::Browser.new<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self<br />
&nbsp;&nbsp;&nbsp;&nbsp; end<br />
&nbsp;&nbsp;&nbsp;&nbsp; def openurl(url)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @browser.goto(url)<br />
&nbsp;&nbsp;&nbsp;&nbsp; end<br />
&nbsp;&nbsp;&nbsp;&nbsp; def set_textarea(text)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @browser.text_field(:id,&#39;kw&#39;).set(text)<br />
&nbsp;&nbsp;&nbsp;&nbsp; end<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; def click<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @browser.button(:id,&#39;su&#39;).click<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end<br />
&nbsp;&nbsp;&nbsp; end<br />
&nbsp;&nbsp;&nbsp; test = TestOneObj.instance<br />
&nbsp;&nbsp;&nbsp; test2 = TestOneObj.instance<br />
&nbsp;&nbsp;&nbsp; p test.inspect<br />
&nbsp;&nbsp;&nbsp; p test2.inspect<br />
&nbsp;&nbsp;&nbsp; test.openurl(&#39;www.baidu.com&#39;)<br />
&nbsp;&nbsp;&nbsp; test2.set_textarea(&#39;aslandhu&#39;)<br />
&nbsp;&nbsp;&nbsp; test.click</code></pre>

<p>上面这段代码试图创建两个Browser对象，但事实上创建的两个对象均为同一个。虽然打开了两个IE窗口，但是对象还是一个，即test与test2是同一个对象。</p>

<p>&nbsp;</p>

